#!/usr/bin/php
<?php

require_once('Spyc.php');

if(file_exists(".mergesources.yml")) {
	$parser = new Spyc();
	$mergeSources = $parser->load(file_get_contents('.mergesources.yml'));

	$svnInfo = new SimpleXMLElement(`svn info --xml`);
	$svnRoot = $svnInfo->entry->repository->root.'';
	$svn = new SVNHelp($svnRoot);
	
	if($_SERVER['argv'][1]) {
		if(strpos($_SERVER['argv'][1], "/") !== false) {
			list($mergeSource, $dir) = explode("/", $_SERVER['argv'][1]);
			$action = "interactive";
		} else {
			$onlyMergeSource = $_SERVER['argv'][1];
			$onlyDir = null;
			$action = "summary";
		}
	} else {
		$action = "summary";
	}
	
	
	switch($action) {
	case "interactive":
		list($mergeSource, $dir) = explode("/", $_SERVER['argv'][1]);
		if(isset($mergeSources[$mergeSource][$dir])) {
			$source = $mergeSources[$mergeSource][$dir];
			if($source[0] != "/") $source = "/$source";

			echo "$dir (from $svnRoot$source)\n";
		 	
			$revs = trim(`svn mergeinfo --show-revs=eligible $svnRoot$source $dir`);
			$revs = $revs ? explode("\n", str_replace("r","", $revs)) : array();
			
			
			$mergebacks = array();
			foreach($revs as $i => $rev) {
				if($svn->isRevMergedFrom($rev, $svn->repos().$source, $dir)) {
					$mergebacks[] = $rev;
					unset($revs[$i]);
				}
			}
			
			if($mergebacks) {
				suggestCommand("svn merge --record-only -c " . implode(",", $mergebacks) . " " 
					.$svn->repos() . $source . " $dir");
				suggestCommand("svn commit $dir -m 'MINOR: Updating mergeinfo to ignore mergebacks'");
			}
			
			$svn->formatMergeReport($revs, $source, $dir);
		} else {
			echo "Can't find merge source $mergeSource/$dir\n";
			exit(2);
		}
		break;
		
	case "summary":
		
		foreach($mergeSources as $name => $items) {
			if($onlyMergeSource && $name != $onlyMergeSource) continue;
			
			echo "Looking for changesets from $name...\n\n";

			foreach($items as $dir => $source) {
				if($onlyDir && $dir != $onlyDir) continue;

				if($source[0] != "/") $source = "/$source";
				echo "$dir (from $svnRoot$source)\n";
				echo `svn mergeinfo --show-revs=eligible $svnRoot$source $dir`;
				echo "\n";
			}
		}
		break;
	}
	
} else {
	echo "Can't find .mergesources.yml\n";
	exit(1);
}

/**
 * Prints the command, waits for a keystroke, and then executes it. saying that the command is being executed
 */
function suggestCommand($command) {
	echo "EXEC: $command [Y\\n]";
	$dummy = trim(fgets(STDIN));
	if(!$dummy || strtolower($dummy[0]) != 'n') {
		passthru($command);
		echo "\n";
	}
}

class SVNHelp {
	protected $repos;

	function __construct($repos) {
		$this->repos = $repos;
	}

	function repos() {
		return $this->repos;
	}
	
	function formatMergeReport($revs, $mergeSource, $dir) {
		$fullMergeSource = $this->repos() . $mergeSource;

		foreach($revs as $rev) {
			$rev = str_replace("r","", $rev);
			suggestCommand("svn merge -c $rev $fullMergeSource $dir");
			suggestCommand("svn commit $dir -m " . escapeshellarg($this->revlog($rev, 'msg', $fullMergeSource)
				. " (from r$rev)"));
		}   
	}
	
	function isRevMergedFrom($rev, $revSource, $originalSource) {
		$svnInfo = new SimpleXMLElement(`svn log -c $rev -g --xml $revSource`);
		foreach($svnInfo->xpath('//logentry/logentry') as $src) {
			$origRev = $src['revision'].'';
			$origSvnInfo = new SimpleXMLElement(`svn log -c $origRev --xml $originalSource`);
			if($origSvnInfo->xpath('//logentry')) {
				return true;
			}
		}
		return false;
	}
	
	
	/**
	 * Get the log message$svn for a single revision
	 */
	function revlog($rev, $infoPart = null, $svnDir = null) {
		if(!$svnDir) $svnDir = $this->repos();
		$xml = new SimpleXMLElement(`svn log --xml -r $rev $svnDir`);
		$info = array(
			'author' => $xml->logentry->author,
			'date' => $xml->logentry->date,
			'msg' => trim($xml->logentry->msg),
		);
		if($infoPart) return $info[$infoPart];
		else return $info;
	}
	
}