#!/usr/bin/php
<?php

require_once('Spyc.php');

if(file_exists(".mergesources.yml")) {
	$parser = new Spyc();
	$mergeSources = $parser->load(file_get_contents('.mergesources.yml'));

	$svnInfo = SVNHelp::xmlCommand("svn info --xml &> /dev/stdout");
	$svnRoot = $svnInfo->entry->repository->root.'';
	$svn = new SVNHelp($svnRoot);

	if($_SERVER['argv'][1]) {
		if(strpos($_SERVER['argv'][1], "/") !== false) {
			list($mergeSource, $dir) = explode("/", $_SERVER['argv'][1]);
			$action = "interactive";
		} else {
			$onlyMergeSource = $_SERVER['argv'][1];
			$onlyDir = null;
			$action = "summary";
		}
	} else {
		$action = "summary";
	}

	$options = $_SERVER['argv'];
	array_shift($options);
	array_shift($options);

	$keyedOptions = array();
	if($options) foreach($options as $option) {
		// NO SPACES!  I'm a bad parser
		if(preg_match('/--*([^=]+)=(.*)/', $option, $matches)) {
			$key = trim(strtolower($matches[1]));
			$val = trim($matches[2]);
			$keyedOptions[$key] = $val;
		}
	}

	if(isset($keyedOptions['startrev'])) $startrev = $keyedOptions['startrev'];
	else $startrev = null;


	switch($action) {
	case "interactive":
		if(isset($mergeSources[$mergeSource][$dir])) {
			$source = $mergeSources[$mergeSource][$dir];

			if(preg_match('/^[a-z]+:\/\//', $source)) {
				echo "Bad merge source: $source\nPlease specify your merge sources relative to the "
					. "repostory root.\n";
				exit(3);
			}

			if($source[0] != "/") $source = "/$source";

			echo "$dir (from $svnRoot$source)\n";

			// Handle the revs argument
			if(isset($keyedOptions['revs'])) {
				$revs = preg_replace('/ *, */', "\n", $keyedOptions['revs']);
			} else {
				$revs = trim(`svn mergeinfo --show-revs=eligible $svnRoot$source $dir`);
			}
			$revs = $revs ? explode("\n", str_replace("r","", $revs)) : array();


			$mergebacks = array();
			foreach($revs as $i => $rev) {
				if($svn->isRevMergedFrom($rev, $svn->repos().$source, $dir)) {
					$mergebacks[] = $rev;
					unset($revs[$i]);
				}
			}

			if($mergebacks && !$startrev && !isset($keyedOptions['revs'])) {
				suggestCommand("svn merge --record-only -c " . implode(",", $mergebacks) . " "
					.$svn->repos() . $source . " $dir");
				suggestCommand("svn commit $dir -m 'MINOR: Updating mergeinfo to ignore mergebacks'");
			}

			$svn->formatMergeReport($revs, $source, $dir, $startrev);
		} else {
			echo "Can't find merge source $mergeSource/$dir\n";
			exit(2);
		}
		break;

	case "summary":
		$nothingFrom = array();

		foreach($mergeSources as $name => $items) {
			if($onlyMergeSource && $name != $onlyMergeSource) continue;

			echo "Looking for changesets from $name...\n\n";

			foreach($items as $dir => $source) {
				if($onlyDir && $dir != $onlyDir) continue;

				if($source[0] != "/") $source = "/$source";
				$revs = trim(`svn mergeinfo --show-revs=eligible $svnRoot$source $dir`);
				if($revs) {
					echo "$dir (from $svnRoot$source)\n$revs\n\n";
				} else {
					$nothingFrom[] = "$name/$dir";
				}
			}
		}

		if($nothingFrom) {
			echo "Nothing to merge from: " . implode(", ", $nothingFrom) . "\n";
		}

		break;
	}

} else {
	echo "Can't find .mergesources.yml\n";
	exit(1);
}

/**
 * Prints the command, waits for a keystroke, and then executes it. saying that the command is being executed
 */
function suggestCommand($command) {
	echo "EXEC: $command [Y\\n]";
	$dummy = trim(fgets(STDIN));
	if(!$dummy || strtolower($dummy[0]) != 'n') {
		passthru($command);
		echo "\n";
	}
}

class SVNHelp {
	protected $repos;

	function __construct($repos) {
		$this->repos = $repos;
	}

	function repos() {
		return $this->repos;
	}

	function formatMergeReport($revs, $mergeSource, $dir, $startrev = null) {
		$fullMergeSource = $this->repos() . $mergeSource;

		$numRevs = sizeof($revs);

		foreach($revs as $i => $rev) {
			$rev = str_replace("r","", $rev);
			if($startrev && $rev < $startrev) continue;

			$logMessage = $this->revlog($rev, 'msg', $fullMergeSource);
			echo "[" . ($i+1) . "/$numRevs] r$rev: $logMessage\n";
			suggestCommand("svn update $dir");
			suggestCommand("svn merge -c $rev $fullMergeSource $dir");
			suggestCommand("svn commit $dir -m " . escapeshellarg($logMessage . " (from r$rev)"));
			echo "\n";
		}
	}

	function isRevMergedFrom($rev, $revSource, $originalSource) {
		$svnInfo = $this->xmlCommand("svn log -c $rev -g --xml $revSource &> /dev/stdout");
		foreach($svnInfo->xpath('//logentry/logentry') as $src) {
			$origRev = $src['revision'].'';
			$origSvnInfo = $this->xmlCommand("svn log -c $origRev --xml $originalSource &> /dev/stdout");
			if($origSvnInfo->xpath('//logentry')) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Get the log message$svn for a single revision
	 */
	function revlog($rev, $infoPart = null, $svnDir = null) {
		if(!$svnDir) $svnDir = $this->repos();
		$xml = $this->xmlCommand("svn log --xml -r $rev $svnDir &> /dev/stdout");
		$info = array(
			'author' => $xml->logentry->author,
			'date' => $xml->logentry->date,
			'msg' => trim($xml->logentry->msg),
		);
		if($infoPart) return $info[$infoPart];
		else return $info;
	}


	/**
	 * Execute a command-line command, parse the result as XML, and return a SimpleXMLElement.
	 * Die with an error message to the user on a failed parse.
	 */
	function xmlCommand($command) {
		try {
			$output = `$command`;
			$svnInfo = @new SimpleXMLElement($output);
		} catch(Exception $e) {
			echo "\nCouldn't run this command - it returned bad XML data:\n$command\n\n";
			echo "The output was as follows:\n$output\n";
			exit(100);
		}
		return $svnInfo;
	}

}